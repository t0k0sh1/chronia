# AI-DLC and Spec-Driven Development

Kiro-style Spec Driven Development implementation on AI-DLC (AI Development Life Cycle)

## Project Context

### Paths
- Steering: `.kiro/steering/`
- Specs: `.kiro/specs/`

### Steering vs Specification

**Steering** (`.kiro/steering/`) - Guide AI with project-wide rules and context
**Specs** (`.kiro/specs/`) - Formalize development process for individual features

### Active Specifications
- Check `.kiro/specs/` for active specifications
- Use `/kiro:spec-status [feature-name]` to check progress

## Development Guidelines
- Think in English, generate responses in Japanese. All Markdown content written to project files (e.g., requirements.md, design.md, tasks.md, research.md, validation reports) MUST be written in the target language configured for this specification (see spec.json.language).
- **Package Manager**: This project uses `pnpm` exclusively. Always use `pnpm` commands instead of `npm`. Note: `pnpm` does not require the `run` keyword for scripts.

### Available Commands
- `pnpm build` - Build the project and verify TypeScript compilation
- `pnpm test` - Run all TDD tests in `tests/` directory
- `pnpm test:coverage` - Run TDD tests with coverage report
- `pnpm test:pbt` - Run property-based tests in `.kiro/specs/` (files matching `*.pbt.test.ts`)
- `pnpm lint` - Run code linting checks
- `pnpm lint:docs` - Run documentation (Markdown) linting checks

## Minimal Workflow
- Phase 0 (optional): `/kiro:steering`, `/kiro:steering-custom`
- Phase 1 (Specification):
  - `/kiro:spec-init "description"`
  - `/kiro:spec-requirements {feature}`
  - `/kiro:validate-gap {feature}` (optional: for existing codebase)
  - `/kiro:spec-design {feature} [-y]`
  - `/kiro:validate-design {feature}` (optional: design review)
  - `/kiro:spec-tasks {feature} [-y]`
- Phase 2 (Implementation): `/kiro:spec-impl {feature} [tasks]`
  - `/kiro:validate-impl {feature}` (optional: after implementation)
- Progress check: `/kiro:spec-status {feature}` (use anytime)

## Development Rules
- 3-phase approval workflow: Requirements â†’ Design â†’ Tasks â†’ Implementation
- Human review required each phase; use `-y` only for intentional fast-track
- Keep steering current and verify alignment with `/kiro:spec-status`
- Follow the user's instructions precisely, and within that scope act autonomously: gather the necessary context and complete the requested work end-to-end in this run, asking questions only when essential information is missing or the instructions are critically ambiguous.

## General Task Workflow (Non-Spec Tasks)

When implementing code changes or writing documentation **without using `/kiro:spec-*` commands**,
follow these verification steps:

### Code Implementation Tasks

After implementing or modifying code:

1. **Write/Update Tests**:
   - Write TDD tests in `tests/` directory
   - Run `pnpm test` to verify all tests pass
   - Run `pnpm test:coverage` to verify comprehensive coverage

2. **Verify Code Quality**:
   - Run `pnpm lint` to check code quality
   - Run `pnpm build` to verify TypeScript compilation
   - Fix any linting or build errors

3. **Code Review** (Recommended):
   - For significant changes, use `code-reviewer` agent for quality assurance
   - Address any identified issues

4. **Update Documentation** (If code affects public APIs):
   - Use `function-docs-writer` agent for function documentation in `docs/functions/`
   - Use `function-docs-writer` agent for category README updates
   - Run `pnpm lint:docs` to verify documentation quality

5. **Commit Changes**:
   - Use `commit-pr-validator` agent to validate, commit, and create PR
   - Agent performs: lint validation, test execution, build verification, git commit, PR creation

**CRITICAL**: All of the following MUST pass before committing:

- âœ… `pnpm lint` (no errors)
- âœ… `pnpm build` (successful compilation)
- âœ… `pnpm test` (all tests passing)
- âœ… `pnpm lint:docs` (if documentation was modified)

### Documentation Tasks

After creating or modifying Markdown files:

1. **Create/Update Documentation**:
   - Use `function-docs-writer` agent for function and category documentation
   - For other Markdown files: Write manually following project standards

2. **Verify Documentation Quality**:
   - Run `pnpm lint:docs` to check Markdown linting
   - Fix any linting errors (blank lines, headings, lists, etc.)

3. **Commit Changes**:
   - Use `commit-pr-validator` agent to validate and commit
   - Agent verifies lint:docs passes before committing

**CRITICAL**: `pnpm lint:docs` MUST pass before committing Markdown changes.

---

## Code Development Workflow

**Context**: This workflow describes the detailed execution process when running `/kiro:spec-impl`
to implement tasks generated by `/kiro:spec-tasks`. These phases are automatically organized as
tasks during the spec-tasks phase and executed sequentially during implementation.

**MANDATORY**: All code changes MUST follow this workflow in order. Each phase uses specialized agents:

### Phase 1: Design (Interface Definition)
**Agent**: `function-interface-designer`

**When to use**:
- Starting a new feature that requires well-defined function signatures
- Refactoring existing code and need to redesign interfaces first
- Creating API contracts before implementation
- After completing requirements but before implementation

**Guidelines**: Follow `docs/guidelines/function-design.md`

**Output**: Function signatures with type annotations, JSDoc comments, and minimal implementation stubs

---

### Phase 2: Implementation & Testing
**Agent**: `function-implementer`

**When to use**:
- After Phase 1 (interface design) is complete
- When function stubs with type signatures need implementation
- Filling in actual logic for predefined interfaces

**Guidelines**: Follow `docs/guidelines/function-implementation.md` and `docs/guidelines/function-testing.md`

**Testing Approach**: Two-phase testing

1. **TDD (Required for all functions)**
   - Write tests in `tests/` directory
   - Use Vitest framework
   - Run `pnpm test` and `pnpm test:coverage`
   - Achieve comprehensive coverage

2. **Property-Based Testing (Required when spec exists)**
   - Write tests in `.kiro/specs/<spec-name>/` directory
   - Use fast-check framework
   - Run `pnpm test:pbt`
   - Verify implementation satisfies specification properties

**Requirements**:
- Implement function bodies according to interface contracts
- Write comprehensive TDD tests (Vitest)
- Ensure all TDD tests pass (`pnpm test`)
- Achieve comprehensive test coverage (`pnpm test:coverage`)
- If spec exists: Write PBT tests in `.kiro/specs/<spec-name>/<function-name>.pbt.test.ts`
- If spec exists: Ensure all PBT tests pass (`pnpm test:pbt`)

**Output**: Fully implemented functions with passing TDD tests and PBT tests (when applicable)

---

### Phase 3: Documentation
**Agent**: `function-docs-writer`

**When to use**:
- After Phase 2 (implementation & testing) is complete
- Before Phase 4 (code review)
- For new functions or modified function behavior

**Workflows**:
1. **Function Documentation Workflow**: Create/update individual function documentation
   - Guidelines: `docs/guidelines/documentation-function.md`
   - Output: `docs/functions/<category>/<function-name>.md`

2. **Category README Workflow**: Update category overview
   - Guidelines: `docs/guidelines/documentation-category.md`
   - Output: `docs/functions/<category>/README.md`

**Requirements**:
- Documentation must be complete and accurate
- All code examples must be runnable
- Documentation reflects current implementation

**Output**: Complete documentation for functions and categories

**Important**: Documentation must be completed before code review (Phase 4) to ensure code and documentation consistency can be verified

---

### Phase 4: Quality Check (Code Review)
**Agent**: `code-reviewer`

**When to use**:
- After Phase 3 (documentation) is complete
- Before committing any code changes
- When significant code has been written or modified

**Checks performed**:
- Code quality and adherence to guidelines
- Security vulnerabilities
- Performance considerations
- Maintainability and readability
- Test coverage adequacy
- Documentation completeness and accuracy

**Guidelines**: Follow `docs/guidelines/function-check.md`

**Requirements**:
- All linting checks pass (`pnpm lint`, `pnpm lint:docs`)
- Build succeeds (`pnpm build`)
- All tests pass (`pnpm test`)
- Documentation exists for all new/modified functions (Phase 3 complete)

**Output**: Code review report with issues identified (if any)

**Iterative Fix Process**:
If the code review identifies issues:
1. **Check Todo List**: Review Todo list for review feedback and identified issues
2. **Fix Issues**: Use `function-implementer` agent to address all review feedback
   - Provide the agent with specific issues from the review report
   - Agent implements fixes following guidelines
   - Agent updates tests if needed
3. **Re-review**: Run `code-reviewer` agent again to verify fixes
4. **Repeat**: Continue this cycle until all issues are resolved and review passes

**Important**: Do NOT proceed to Phase 5 (PBT Validation) until Quality Check passes with no issues

---

### Phase 5: PBT Validation (Property-Based Testing)
**Agent**: `pbt-spec-validator`

**When to use**:
- After Phase 4 (quality check) passes
- When functions have been created or modified
- When a specification exists for the feature

**What it validates**:
- Implementation satisfies specification properties
- Functions behave correctly across wide range of inputs
- Edge cases and boundary conditions are handled
- Specification requirements are met

**Guidelines**: Follow `docs/guidelines/property-based-testing.md`

**Requirements**:
- Code review must pass (Phase 4 complete)
- Specification must exist in `.kiro/specs/`
- TDD tests must already pass

**Output**: Property-based test results with pass/fail status

**Iterative Fix Process**:
If property-based tests fail:
1. **Analyze Failures**: Review failing test cases and counterexamples
2. **Fix Implementation**: Use `function-implementer` agent to fix issues
   - Update function implementation to satisfy properties
   - Ensure TDD tests still pass
3. **Re-validate**: Run `pbt-spec-validator` again to verify fixes
4. **Repeat**: Continue until all property-based tests pass

**Important**: Do NOT proceed to Phase 6 (Commit & PR) until PBT validation passes

---

### Phase 6: Commit & PR (Validation & Submission)
**Agent**: `commit-pr-validator`

**When to use**:
- After all previous phases are complete
- When ready to submit code for review
- Before pushing changes to remote

**Validations performed**:
- Final quality checks (lint, test, build)
- Documentation completeness verification
- Git commit creation with proper message format
- Pull request creation with comprehensive description

**Requirements**:
- All quality checks must pass
- Documentation must be synchronized with code
- Commit message follows project conventions
- PR description includes summary and test plan

**Output**: Git commit and pull request created

---

### Workflow Summary

```
1. Design                    â†’ function-interface-designer  â†’ Function signatures & contracts
2. Implementation            â†’ function-implementer        â†’ Working code with TDD tests
   â”œâ”€ After all implementation tasks complete
   â””â”€ Run: pnpm lint, pnpm lint:docs, pnpm build
      â”œâ”€ Lint/build fail? â†’ Fix issues and re-run
      â””â”€ Pass? â†’ Proceed to Phase 3
3. Documentation             â†’ function-docs-writer         â†’ Complete documentation
   â””â”€ Proceed to Phase 4
4. Quality Check (Review)    â†’ code-reviewer               â†’ Code quality validation
   â”œâ”€ Issues found?
   â”‚  â”œâ”€ YES â†’ Check Todo list for review feedback
   â”‚  â”‚       â†’ Use function-implementer to fix issues
   â”‚  â”‚       â†’ Re-run code-reviewer (repeat until clean)
   â”‚  â””â”€ NO  â†’ Proceed to Phase 5
5. PBT Validation            â†’ pbt-spec-validator          â†’ Property-based testing
   â”œâ”€ Tests fail?
   â”‚  â”œâ”€ YES â†’ Use function-implementer to fix issues
   â”‚  â”‚       â†’ Re-run pbt-spec-validator (repeat until pass)
   â”‚  â””â”€ NO  â†’ Proceed to Phase 6
6. Commit & PR               â†’ commit-pr-validator         â†’ Git commit & pull request
```

### Workflow Enforcement

**CRITICAL RULES**:
- Never skip phases (always follow the order)
- Each phase must complete successfully before proceeding
- Use the specified agent for each phase
- Address all issues raised before moving to the next phase
- **Linting & Build Verification**: After Phase 2 (Implementation) completes:
  - Run `pnpm lint`, `pnpm lint:docs`, `pnpm build`
  - Fix any linting or build errors before proceeding to Phase 3
  - Do NOT proceed to Documentation until all checks pass
- **Documentation Requirement**: Phase 3 (Documentation) is MANDATORY after implementation
  - Create/update function documentation files
  - Update category README if needed
  - Run `pnpm lint:docs` to verify documentation quality
  - Do NOT proceed to Phase 4 until documentation is complete
- **Quality Check Iteration**: If Phase 4 (code-reviewer) identifies issues:
  - Check Todo list for review feedback
  - Use `function-implementer` to fix ALL issues
  - Re-run `code-reviewer` to verify fixes
  - Repeat until review passes with no issues
  - Do NOT proceed to Phase 5 until Quality Check is clean
- **PBT Validation Iteration**: If Phase 5 (pbt-spec-validator) tests fail:
  - Use `function-implementer` to fix implementation
  - Ensure TDD tests still pass
  - Re-run `pbt-spec-validator` to verify fixes
  - Repeat until all property-based tests pass
  - Do NOT proceed to Phase 6 until PBT validation passes
- **PBT Requirement**: Phase 5 is REQUIRED when functions are created or modified
- **Non-Spec Task Verification**: When implementing tasks without `/kiro:spec-impl`:
  - For code changes: Run `pnpm lint`, `pnpm build`, `pnpm test` before committing
  - For documentation changes: Run `pnpm lint:docs` before committing
  - All checks must pass before creating git commits

**Exception**: For minor documentation-only changes or typo fixes, you may skip directly to Phase 6.

## Documentation Rules

### Guidelines Reference
- **Function Documentation**: Follow `docs/guidelines/documentation-function.md` for individual function documentation (8-section structure)
- **Category README**: Follow `docs/guidelines/documentation-category.md` for category overview documentation (11-section structure)

### When to Document

#### Function Documentation (Required)
Use the `function-docs-writer` agent with the **Function Documentation Workflow** in the following cases:

1. **New Function Created**: Immediately after creating a new function in `src/`, create its documentation file in `docs/functions/<category>/<function-name>.md`
2. **Function Modified**: When modifying a function's:
   - Signature (parameters, return type)
   - Behavior or logic
   - Error handling
   - Performance characteristics
   Update the corresponding documentation file
3. **Before Committing**: Always ensure function documentation is complete and up-to-date before creating a git commit

#### Category README Documentation (Required)
Use the `function-docs-writer` agent with the **Category README Workflow** in the following cases:

1. **New Function Added to Category**: When a new function is added to a category, update the category's `README.md` to:
   - Add the function to the "Available Functions" table
   - Update "Use Case Guide" if the function addresses new scenarios
   - Add relevant patterns to "Common Patterns" section if applicable
2. **Function Behavior Changed**: When a function's behavior or purpose changes significantly, update the category README to reflect:
   - Updated descriptions in function tables
   - Revised use case recommendations
   - Modified common patterns that use the function
3. **Before Committing**: Always ensure category README is up-to-date before creating a git commit

#### Project Root README Documentation (Required)

When new functions are added to the project, the project root `README.md` MUST be updated manually to maintain the "Function Categories" section:

1. **When to Update**:
   - When new functions are added to `src/` and exported in `src/index.ts`
   - When the function count changes
   - When new function categories or subsections are introduced

2. **Update Procedure**:
   - **Locate the "Function Categories" section** (typically around line 71)
   - **Update total function count**: Change "X functions" to reflect the new total
     - Example: "70 functions" â†’ "72 functions"
     - Update BOTH occurrences (main section header and documentation structure description)
   - **Update category subsections**:
     - Add new functions to the appropriate category subsection (e.g., **Relational**, **Equality**, **Current Time Comparison**, **Validation**)
     - Update category function count (e.g., "Comparison (14 functions)" â†’ "Comparison (16 functions)")
     - Create new subsections if the function represents a new concept (e.g., **Current Time Comparison** for `isFuture`/`isPast`)
   - **Update documentation links**: Add or modify links to relevant category documentation
   - **Maintain consistency**: Keep subsection structure aligned with `docs/functions/<category>/README.md`
   - **Verify formatting**: Run `pnpm lint:docs` to ensure Markdown quality

3. **Function Count Calculation**:
   - Count only exported functions in `src/index.ts`
   - **Exclude**: `constants`, `types`, `i18n` (these are not functions)
   - Example calculation: 73 exports - 1 (constants) - 1 (types) - 1 (i18n) = 70 functions

**CRITICAL**: Project root `README.md` MUST be updated BEFORE committing when new functions are added. This ensures the main project documentation stays synchronized with the codebase.

### Documentation Workflow Order

**CRITICAL**: Documentation must be completed AFTER implementation and BEFORE code review.

```markdown
1. Implement/modify function(s) in src/
2. Write/update tests (TDD)
3. Run tests and ensure they pass
4. Run linting and build (pnpm lint, pnpm build)
5. Document individual function(s) using function-docs-writer (Function Documentation Workflow)
6. Update category README using function-docs-writer (Category README Workflow)
7. Update project root README.md (if new functions added)
   - Update "Function Categories" section with new functions
   - Update total function count (both occurrences)
   - Update category function counts
8. Run documentation linting (pnpm lint:docs)
9. Verify all documentation is accurate and complete
10. Run code review (code-reviewer)
11. Run property-based tests (pbt-spec-validator) - if functions created/modified
12. Create git commit (commit-pr-validator)
```

### Responding to Feedback

#### Pull Request Review Workflow

**CRITICAL**: Always use the `pr-review-triager` agent to systematically read, analyze, and triage PR review feedback.

**PR Tracking File**: For spec-based development, PR information and review feedback are tracked in `.kiro/specs/[spec-name]/pr.md`:
- **Auto-generated**: Created by `commit-pr-validator` agent after PR creation
- **Contains**: PR number, title, URL, branch name, review feedback with action items and status
- **Benefits**:
  - No need to repeatedly provide PR number to agents
  - Persistent tracking across multiple review cycles
  - Clear overview of all feedback and resolution status
  - Structured todo list for addressing feedback

**Template Location**: `.kiro/settings/templates/specs/pr.md`

##### Step 1: Read and Triage Review Feedback

**When to use pr-review-triager**:
- After PR is created and review comments are received
- Periodic check for new review feedback
- Before deciding which feedback to address
- When multiple reviewers provide conflicting feedback

**What the agent does**:
1. **Detects PR tracking file** (`.kiro/specs/[spec-name]/pr.md`) to auto-load PR number
2. **Fetches all review feedback** using GitHub MCP tools
3. **Categorizes by severity**: Critical, Major, Minor, Nitpick
4. **Analyzes each item** with clear reasoning
5. **Presents structured report** showing what to fix and what to skip
6. **Asks user for decisions** on which items to address
7. **Updates pr.md** with all feedback items and user decisions
8. **Creates Todo items** for selected fixes
9. **Recommends next agents** (function-implementer or function-docs-writer)

**Agent Usage**:
```bash
# Use pr-review-triager agent (no need to specify PR number if pr.md exists)
Task tool: pr-review-triager
Prompt: "Analyze review feedback and provide triage recommendations.
         Present findings with clear reasoning for each item."

# If pr.md doesn't exist yet, specify PR number
Task tool: pr-review-triager
Prompt: "Analyze review feedback for PR #[number] and provide triage recommendations.
         Present findings with clear reasoning for each item."
```

**Expected Output**:
- Comprehensive triage report in English (structured markdown)
- Clear categorization: MUST FIX / SHOULD FIX / CONSIDER / OPTIONAL / NO FIX NEEDED
- Reasoning for each recommendation
- User decision questions (in Japanese)
- Action plan with agent prompts for fixes

**Manual GitHub MCP Usage** (if not using agent):

1. **Read Pull Request Reviews**:
   - Use `mcp__GitHub__get_pull_request_reviews` to get all review comments
   - Parameters: `owner`, `repo`, `pull_number`
   - Returns: Review comments with state (APPROVED, COMMENTED, CHANGES_REQUESTED)

2. **Read Pull Request Comments**:
   - Use `mcp__GitHub__get_pull_request_comments` to get inline code comments
   - Parameters: `owner`, `repo`, `pull_number`
   - Returns: Line-by-line code review comments

3. **Get Pull Request Details**:
   - Use `mcp__GitHub__get_pull_request` to get PR metadata
   - Parameters: `owner`, `repo`, `pull_number`
   - Returns: PR status, description, files changed

**Example**:
```typescript
// Read PR #26 reviews manually
mcp__GitHub__get_pull_request_reviews(owner: "t0k0sh1", repo: "chronia", pull_number: 26)
mcp__GitHub__get_pull_request_comments(owner: "t0k0sh1", repo: "chronia", pull_number: 26)
```

**Do NOT**:
- Manually browse GitHub web interface
- Ask user to copy/paste review comments
- Use web scraping or unofficial APIs
- Analyze feedback without using pr-review-triager agent (unless trivial)

##### Step 2: Severity-Based Decision Criteria

**Severity-Based Action Guidelines**:

1. **Critical** (Security Vulnerabilities, Breaking Changes, Data Loss, Logic Errors):
   - âœ… **MUST FIX**: Immediately address all critical issues
   - Use `function-implementer` agent for code fixes
   - Add regression tests to prevent recurrence
   - Run full validation suite before pushing
   - **Example**: "Security: Potential XSS vulnerability in input handling"

2. **Major** (Performance Issues, API Design Flaws, Incorrect Behavior):
   - âœ… **SHOULD FIX**: Address unless there's a strong technical reason not to
   - Use `function-implementer` agent for implementation fixes
   - If disagreeing, provide detailed technical justification in PR comments
   - May require design discussion before fixing
   - **Example**: "Performance: O(nÂ²) algorithm should be O(n log n)"

3. **Minor** (Code Style, Naming Conventions, Code Organization):
   - ðŸ¤” **CONSIDER**: Fix if aligned with project conventions
   - Use `function-implementer` agent for code style fixes
   - May discuss alternative approaches
   - Balance consistency vs change overhead
   - **Example**: "Style: Variable name should follow camelCase convention"

4. **Nitpick** (Formatting, Comment Wording, Trivial Suggestions):
   - ðŸ“ **OPTIONAL**: Fix if quick and non-controversial
   - Can defer to future refactoring
   - Acknowledge but don't block PR on these
   - **Example**: "Nitpick: Extra blank line at end of file"

**Documentation-Specific Severity**:

1. **Critical Documentation Issues**:
   - Incorrect API documentation (wrong parameters, return types)
   - Missing safety warnings or error conditions
   - Broken or incorrect code examples
   - âœ… **MUST FIX** with `function-docs-writer` agent

2. **Major Documentation Issues**:
   - Incomplete usage examples
   - Missing edge case documentation
   - Unclear or ambiguous descriptions
   - âœ… **SHOULD FIX** with `function-docs-writer` agent

3. **Minor Documentation Issues**:
   - Typos, grammar issues
   - Formatting inconsistencies
   - Missing links or cross-references
   - ðŸ¤” **CONSIDER** fixing with `function-docs-writer` agent

**Reviewer Priority**:
- **Maintainer feedback** > Contributor feedback > AI bot suggestions
- **AI bots** (Gemini Code Assist, CodeRabbit): Treat as automated static analysis
  - Often catch edge cases and best practices
  - Verify suggestions are relevant before applying
- **Human reviewers**: Engage in discussion when needed
  - Ask clarifying questions for ambiguous feedback
  - Provide context if disagreeing

##### Step 3: Address Selected Feedback

When addressing user feedback or PR review comments that affect functionality:

1. **Review User Decision**: Review triage report and decide which items to address
   - Agent will ask for decisions via AskUserQuestion
   - Consider severity, reasoning, and effort estimates
2. **Fix Code Issues**: Use `function-implementer` agent to implement code changes
   - Provide specific review feedback to the agent
   - Agent implements fixes following project guidelines
   - Agent updates tests if needed
3. **Fix Documentation Issues**: Use `function-docs-writer` agent for documentation changes
   - Individual function documentation updates
   - Category README updates
4. **Verify Fixes**: Run validation suite
   - `pnpm lint` - Code quality
   - `pnpm test` - All tests pass
   - `pnpm build` - Compilation success
   - `pnpm lint:docs` - Documentation quality (if docs changed)
5. **Commit Changes**: Commit code and documentation updates together
6. **Push Update**: Push changes to update the pull request

**CRITICAL**: Always use appropriate agents for fixes:
- **Code changes** â†’ Use `function-implementer` agent
- **Documentation changes** â†’ Use `function-docs-writer` agent
- **Never fix manually** â†’ Always delegate to specialized agents

**Fix Implementation Workflow**:

For **code-related feedback**:
```bash
# 1. Use function-implementer agent
Task tool: function-implementer
Prompt: "Address the following review feedback: [paste specific feedback].
         Fix the code in [file path] and update tests if needed."

# 2. Verify the fix
pnpm lint
pnpm test
pnpm build
```

For **documentation-related feedback**:
```bash
# 1. Use function-docs-writer agent
Task tool: function-docs-writer
Prompt: "Update documentation to address review feedback: [paste specific feedback].
         Update [function/category] documentation in docs/functions/."

# 2. Verify documentation quality
pnpm lint:docs
```

**Complete Fix Validation Checklist**:
- [ ] Review feedback read via GitHub MCP tools
- [ ] Severity categorized and action determined
- [ ] Code fixes implemented by `function-implementer` (if applicable)
- [ ] Documentation fixes implemented by `function-docs-writer` (if applicable)
- [ ] All tests pass (`pnpm test`)
- [ ] Code quality verified (`pnpm lint`)
- [ ] Build succeeds (`pnpm build`)
- [ ] Documentation quality verified (`pnpm lint:docs`, if docs changed)
- [ ] Changes committed with clear message referencing review feedback
- [ ] PR updated with push

### Agent Usage

**Separate Workflows**: Use `function-docs-writer` agent with explicit workflow specification:

```typescript
// For individual function documentation
Task tool: function-docs-writer
Prompt: "Create documentation for the [functionName] function in src/[path].
         Use the Function Documentation Workflow and follow docs/guidelines/documentation-function.md."

// For category README
Task tool: function-docs-writer
Prompt: "Update the README.md for the [categoryName] category to include [changes].
         Use the Category README Workflow and follow docs/guidelines/documentation-category.md."
```

### Documentation Synchronization

- **Keep in Sync**: Documentation must always reflect the current state of the code
- **No Stale Docs**: Never commit code changes without updating corresponding documentation
- **Accuracy First**: Documentation accuracy is as important as code correctness
- **Examples Must Work**: All code examples in documentation must be syntactically correct and runnable

## Steering Configuration
- Load entire `.kiro/steering/` as project memory
- Default files: `product.md`, `tech.md`, `structure.md`
- Custom files are supported (managed via `/kiro:steering-custom`)
